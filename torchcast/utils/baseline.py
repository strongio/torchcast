from typing import Sequence, Union

import pandas as pd


def make_baseline(data: pd.DataFrame,
                  group_colnames: Sequence[str],
                  time_colname: str,
                  value_colname: str,
                  is_train: Union[str, callable],
                  lag: int,
                  smooth: int) -> pd.DataFrame:
    """
    Generate a dataframe with a baseline forecast for each group in the data. The baseline forecast is generated by
    taking the lagged value of the target, possibly smoothed first.

    :param data: The data to generate the baseline forecast for.
    :param group_colnames: The column name(s) for the groups.
    :param time_colname: The column name for the times.
    :param value_colname: The column name for the target values.
    :param is_train: A boolean column (or a function that takes the data and returns a boolean column) indicating
     whether each row belongs to the training set.
    :param lag: The number of time-steps to lag the target by. Note that currently each row is assumed to be a timestep,
     with no implicit (or explicit) missings.
    :param smooth: The window size to use for smoothing the target. Set to 0 to disable smoothing.
    :return: A dataframe with `group_colnames`, `time_colname`, and `baseline` columns.
    """
    if isinstance(group_colnames, str):
        group_colnames = [group_colnames]

    if callable(is_train):
        data = data.assign(is_train=is_train)
        is_train = 'is_train'
    out = data[list(group_colnames) + [time_colname, value_colname, is_train]].reset_index(drop=True)

    if not out.groupby(group_colnames)[time_colname].is_monotonic_increasing.all():
        out = out.sort_values(time_colname).reset_index(drop=True)
    diffs = out.groupby(group_colnames)[time_colname].diff().drop_duplicates().dropna()
    if len(diffs) > 1:
        raise ValueError(
            "Currently this function only supports data without implicit missings (i.e. ``df[time_colname].diff()`` "
            "is always the same value except across groups)."
        )

    # avoid data-leakage:
    out[value_colname] = out[value_colname].where(out[is_train])

    # apply smoothing:
    if smooth:
        # @formatter:off
        out[value_colname] = (out
                              .groupby(group_colnames, sort=False)
                              [value_colname].rolling(window=smooth)
                              .mean()
                              .reset_index(level=tuple(range(len(group_colnames))), drop=True))
        # @formatter:on

    # create prediction (lagged value)
    out['baseline'] = out.groupby(group_colnames)[value_colname].shift(lag)
    del out[value_colname]

    # repeatedly apply lag to prediction to forecast into the future:
    prop_null = out.loc[~out[is_train], 'baseline'].isnull().mean()
    while True:
        last_prop_null = prop_null
        out['baseline'] = out['baseline'].fillna(out.groupby(group_colnames)['baseline'].shift(lag))
        prop_null = out.loc[~out[is_train], 'baseline'].isnull().mean()
        if prop_null == last_prop_null:
            break
        # print(prop_null)
    return out[~out.pop(is_train)].reset_index(drop=True)
